import datetime


class GCodeLogic:
    def generate(self, config, cut_paths, score_paths):
        self.config = config
        start_gcode = self.config["start_gcode"].format(**self.config)
        end_gcode = self.config["end_gcode"].format(**self.config)

        body_gcode = []
        stats = {"distance": 0.0, "time": 0.0, "tool_changes": 0}

        # Remove duplicate paths
        def dedup_paths(paths):
            seen = set()
            unique = []
            for path in paths:
                t = tuple(tuple(tuple(round(coord, 4) for coord in pt) for pt in subpath) for subpath in path)
                if t not in seen:
                    seen.add(t)
                    unique.append(path)
            return unique

        cut_paths = dedup_paths(cut_paths)
        score_paths = dedup_paths(score_paths)

        z_mode = self.config.get("z_mode", "servo")
        
        if score_paths:
            body_gcode.append("; --- Scoring Paths ---")
            g, s = self._process_paths(score_paths, "scoring", z_mode)
            body_gcode.extend(g)
            stats["distance"] += s["distance"]
            stats["time"] += s["time"]
            stats["tool_changes"] += s["tool_changes"]

        if cut_paths:
            body_gcode.append("; --- Cutting Paths ---")
            g, s = self._process_paths(cut_paths, "cutting", z_mode)
            body_gcode.extend(g)
            stats["distance"] += s["distance"]
            stats["time"] += s["time"]
            stats["tool_changes"] += s["tool_changes"]

        now = datetime.datetime.now()
        header = f"; Generated by JD CNC Gcode Generator at {now.strftime('%H:%M:%S %d/%m/%y')}\n"

        return header + "\n" + "\n".join([start_gcode] + body_gcode + [end_gcode]), stats

    def _process_paths(self, paths, process_type, z_mode):
        gcode = []
        stats = {"distance": 0.0, "time": 0.0, "tool_changes": 0}

        # Convert speeds from mm/s to mm/min for G-code
        def to_mm_min(val):
            try:
                return float(val) * 60
            except Exception:
                return float(val)

        if z_mode == "stepper":
            if process_type == "scoring":
                z_height = self.config.get("z_stepper_score_height", "-0.5")
            else:
                z_height = self.config.get("z_stepper_cut_height", "-2.0")
            z_travel = self.config.get("z_stepper_travel_height", "5.0")
            speed = to_mm_min(self.config["scoring_speed"] if process_type == "scoring" else self.config["cutting_speed"])
            travel_speed = to_mm_min(self.config["travel_speed"])
            z_plunge_speed = to_mm_min(self.config.get("z_plunge_speed", 20))
            z_raise_speed = to_mm_min(self.config.get("z_raise_speed", 20))
            last_point = None
            head_is_up = True
            for path in paths:
                for sub in path:
                    if not sub:
                        continue
                    start_point = self._apply_offsets_and_origin(sub[0])
                    if last_point:
                        dist = ((start_point[0] - last_point[0]) ** 2 + (start_point[1] - last_point[1]) ** 2) ** 0.5
                        stats["distance"] += dist
                        stats["time"] += dist / travel_speed if travel_speed else 0
                    # Only lift if not already up
                    if not head_is_up:
                        gcode.append(f"G0 F{z_raise_speed} Z{z_travel}")
                        head_is_up = True
                    gcode.append(f"G0 F{travel_speed} X{start_point[0]:.3f} Y{start_point[1]:.3f}")
                    gcode.append(f"G1 F{z_plunge_speed} Z{z_height}")
                    head_is_up = False
                    stats["tool_changes"] += 1
                    last = start_point
                    for point in sub[1:]:
                        p = self._apply_offsets_and_origin(point)
                        dist = ((p[0] - last[0]) ** 2 + (p[1] - last[1]) ** 2) ** 0.5
                        stats["distance"] += dist
                        stats["time"] += dist / speed if speed else 0
                        gcode.append(f"G1 F{speed} X{p[0]:.3f} Y{p[1]:.3f}")
                        last = p
                    gcode.append(f"G0 F{z_raise_speed} Z{z_travel}")
                    head_is_up = True
                    last_point = sub[-1]
            return gcode, stats
        else:
            # Servo mode
            speed = to_mm_min(self.config["scoring_speed"] if process_type == "scoring" else self.config["cutting_speed"])
            servo_angle = self.config["servo_score"] if process_type == "scoring" else self.config["servo_cut"]
            travel_speed = to_mm_min(self.config["travel_speed"])
            servo_travel_angle = self.config["servo_travel"]
            servo_delay_str = self.config.get("servo_delay", "200")
            try:
                servo_delay = float(servo_delay_str) if servo_delay_str.strip() else 200.0
            except ValueError:
                servo_delay = 200.0
            last_point = None
            for path in paths:
                for sub in path:
                    if not sub:
                        continue
                    start_point = self._apply_offsets_and_origin(sub[0])
                    if last_point:
                        dist = ((start_point[0] - last_point[0]) ** 2 + (start_point[1] - last_point[1]) ** 2) ** 0.5
                        stats["distance"] += dist
                        stats["time"] += dist / travel_speed if travel_speed else 0
                    gcode.append(f"M280 P0 S{servo_travel_angle} ; Tool up (travel)")
                    gcode.append(f"G0 F{travel_speed} X{start_point[0]:.3f} Y{start_point[1]:.3f}")
                    gcode.append(f"M280 P0 S{servo_angle} ; Tool {process_type}")
                    gcode.append(f"G4 P{servo_delay} ; Wait for servo")
                    stats["tool_changes"] += 1
                    last = start_point
                    for point in sub[1:]:
                        p = self._apply_offsets_and_origin(point)
                        dist = ((p[0] - last[0]) ** 2 + (p[1] - last[1]) ** 2) ** 0.5
                        stats["distance"] += dist
                        stats["time"] += dist / speed if speed else 0
                        gcode.append(f"G1 F{speed} X{p[0]:.3f} Y{p[1]:.3f}")
                        last = p
                    gcode.append(f"M280 P0 S{servo_travel_angle} ; Tool up (travel)")
                    last_point = sub[-1]
            return gcode, stats

    def _apply_offsets_and_origin(self, point):
        x, y = point
        x += float(self.config.get("tool_offset_x", 0))
        y += float(self.config.get("tool_offset_y", 0))

        bed_width = float(self.config.get("bed_width", 0))
        bed_height = float(self.config.get("bed_height", 0))
        origin = self.config.get("origin_point", "front_left")
        margin = float(self.config.get("safety_margin", 5))

        # Handle Y-axis inversion based on origin
        if origin == "front_left":
            x_out, y_out = (x, bed_height - y)
        elif origin == "front_right":
            x_out, y_out = (bed_width - x, bed_height - y)
        elif origin == "back_left":
            x_out, y_out = (x, y)  # No inversion for back left
        elif origin == "back_right":
            x_out, y_out = (bed_width - x, y)
        elif origin == "center":
            # Center the design on the bed
            x_out, y_out = (x + (bed_width/2), y + (bed_height/2))
        else:
            x_out, y_out = (x, y)
        
        # Apply safety margin
        x_out = max(margin, min(bed_width - margin, x_out))
        y_out = max(margin, min(bed_height - margin, y_out))
        
        return (x_out, y_out)